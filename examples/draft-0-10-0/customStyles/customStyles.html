<!--
Copyright (c) Facebook, Inc. and its affiliates. All rights reserved.

This file provided by Facebook is for non-commercial testing and evaluation
purposes only. Facebook reserves all rights not expressly granted.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Draft â€¢ Rich Text</title>
    <link rel="stylesheet" href="../../../dist/Draft.css" />
    <link rel="stylesheet" href="RichEditor.css" />
    <style>
      #target { width: 600px; }
      .docs { width: 800px; }
      body { font-family: 'Georgia', serif }
    </style>
  </head>
  <body>
    <div class="docs">
      <h1>DraftJS Inline style customization test</h1>
      <p>This page showcases customizations of the DraftJS editor and scenarios for it's testing. It is also a documentation for the type of customizations made.</p>
      <h2>Class name support for inline styles</h2>
      <p>DraftJS editor supports natively only inline styles rendered directly to the editor leaf DOM nodes. With this customization <code>className</code> property can be added to the style object and it renders to the <code>class</code> attribute in the resulting HTML.</p>
      <p>Add text and apply <strong>Leaf</strong> inline style from the toolbar. The style should be applied (Kontent.ai logo <span class="rte__inline-leaf rte__inline-leaf-programmatic" style="display: inline-block; text-decoration: underline;">leaf</span> design), there should be inline style <code>display: inline-block; text-decoration: underline;</code> and class names <code>rte__inline-leaf rte__inline-leaf-programmatic</code> rendered.</p>
      <p>It should combine well with the <strong>Highlight</strong> inline style from the toolbar which should apply <span class="rte__highlight">highlight</span> and class name <code>rte__highlight</code> and mix properly with the other styles including <strong>LEAF</strong> like this: <span class="rte__inline-leaf rte__inline-leaf-programmatic" style="display: inline-block; text-decoration: underline;">Hello </span><span class="rte__inline-leaf rte__inline-leaf-programmatic rte__highlight" style="display: inline-block; text-decoration: underline;">world</span></p>
      <h2>RTL short-circuit</h2>
      <p>We disabled the default handling of RTL detection in individual blocks for performance reasons. No need to test it here.</p>
      <h2><code>getIn</code> error</h2>
      <p>This is a test for a null reference bug which was fixed in <code>v0.11.5</code>. Start selection in one of the editors, extend it to another editor. There should be no <code>getIn</code> error in the console. In development mode, there can be a warning about invalid selection.</p>
    </div>
    <div id="target"></div>
    <script src="../../../node_modules/react/umd/react.development.js"></script>
    <script src="../../../node_modules/react-dom/umd/react-dom.development.js"></script>
    <script src="../../../node_modules/immutable/dist/immutable.js"></script>
    <script src="../../../node_modules/es6-shim/es6-shim.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js"></script>
    <script src="../../../dist/Draft.js"></script>
    <script type="text/babel">
      'use strict';

      const {CharacterMetadata, ContentState, Editor, EditorState, RichUtils, getDefaultKeyBinding, UserSelection} = Draft;
      const {List, Set} = Immutable;

      class RichEditorExample extends React.Component {
        constructor(props) {
          super(props);
          this.state = {editorState: EditorState.createWithContent(props.content ? props.content : ContentState.createFromText(''))};

          this.focus = () => this.refs.editor.focus();
          this.onChange = (editorState) => {
            if (props.disabled && (editorState.getCurrentContent() !== this.state.editorState.getCurrentContent())) {
              alert('This editor does not allow content changes');
              this.setState({editorState: EditorState.forceSelection(this.state.editorState, this.state.editorState.getSelection())});
            }
            else {
              this.setState({editorState});
            }
          };

          this.handleKeyCommand = this._handleKeyCommand.bind(this);
          this.mapKeyToEditorCommand = this._mapKeyToEditorCommand.bind(this);
          this.toggleBlockType = this._toggleBlockType.bind(this);
          this.toggleInlineStyle = this._toggleInlineStyle.bind(this);
          this.insertSoftNewLine = this._insertSoftNewLine.bind(this);
        }

        _handleKeyCommand(command, editorState) {
          const newState = RichUtils.handleKeyCommand(editorState, command);
          if (newState) {
            this.onChange(newState);
            return true;
          }
          return false;
        }

        _mapKeyToEditorCommand(e) {
          if (e.keyCode === 9 /* TAB */) {
            const newEditorState = RichUtils.onTab(
              e,
              this.state.editorState,
              4, /* maxDepth */
            );
            if (newEditorState !== this.state.editorState) {
              this.onChange(newEditorState);
            }
            return;
          }
          return getDefaultKeyBinding(e);
        }

        _toggleBlockType(blockType) {
          this.onChange(
            RichUtils.toggleBlockType(
              this.state.editorState,
              blockType
            )
          );
        }

        _insertSoftNewLine() {
          this.onChange(
              RichUtils.insertSoftNewline(this.state.editorState)
          );
        }

        _toggleInlineStyle(inlineStyle) {
          this.onChange(
            RichUtils.toggleInlineStyle(
              this.state.editorState,
              inlineStyle
            )
          );
        }

        render() {
          const {editorState} = this.state;

          // If the user changes block type before entering any text, we can
          // either style the placeholder or hide it. Let's just hide it now.
          let className = 'RichEditor-editor';
          var contentState = editorState.getCurrentContent();
          if (!contentState.hasText()) {
            if (contentState.getBlockMap().first().getType() !== 'unstyled') {
              className += ' RichEditor-hidePlaceholder';
            }
          }

          return (
            <div className="RichEditor-root">
              <BlockStyleControls
                editorState={editorState}
                onToggle={this.toggleBlockType}
              />
              <InlineStyleControls
                editorState={editorState}
                onToggle={this.toggleInlineStyle}
              />
              <button onClick={this.insertSoftNewLine}>Insert soft new line</button>
              <div className={className} onClick={this.focus}>
                <Editor
                  blockStyleFn={getBlockStyle}
                  customStyleMap={styleMap}
                  editorState={editorState}
                  handleKeyCommand={this.handleKeyCommand}
                  keyBindingFn={this.mapKeyToEditorCommand}
                  customStyleFn={getCustomStyle}
                  onChange={this.onChange}
                  placeholder="Tell a story..."
                  ref="editor"
                  spellCheck={true}
                />
              </div>
            </div>
          );
        }
      }

      // Custom overrides for "code" style.
      const styleMap = {
        CODE: {
          backgroundColor: 'rgba(0, 0, 0, 0.05)',
          fontFamily: '"Inconsolata", "Menlo", "Consolas", monospace',
          fontSize: 16,
          padding: 2,
        },

        LEAF: {
          className: 'rte__inline-leaf',
          display: 'inline-block',
        },

        HIGHLIGHT: {
          className: 'rte__highlight',
          display: 'inline-block',
        },
      };

      function getBlockStyle(block) {
        switch (block.getType()) {
          case 'blockquote': return 'RichEditor-blockquote';
          default: return block.getText() ? null : 'block--is-empty';
        }
      }

      function getCustomStyle(style) {
        const collaborativeClassNames = style
          .filter(s => s.indexOf('--') > 0)
          .toArray();

        if (style.includes('LEAF')) {
          return {
            className: ['rte__inline-leaf-programmatic', ...collaborativeClassNames].join(' '),
            textDecoration: 'underline',
          };
        }
        return collaborativeClassNames.length ? { className: collaborativeClassNames.join(' ') } : {};
      }

      class StyleButton extends React.Component {
        constructor() {
          super();
          this.onToggle = (e) => {
            e.preventDefault();
            this.props.onToggle(this.props.style);
          };
        }

        render() {
          let className = 'RichEditor-styleButton';
          if (this.props.active) {
            className += ' RichEditor-activeButton';
          }

          return (
            <span className={className} onMouseDown={this.onToggle}>
              {this.props.label}
            </span>
          );
        }
      }

      const BLOCK_TYPES = [
        {label: 'H1', style: 'header-one'},
        {label: 'H2', style: 'header-two'},
        {label: 'H3', style: 'header-three'},
        {label: 'H4', style: 'header-four'},
        {label: 'H5', style: 'header-five'},
        {label: 'H6', style: 'header-six'},
        {label: 'Blockquote', style: 'blockquote'},
        {label: 'UL', style: 'unordered-list-item'},
        {label: 'OL', style: 'ordered-list-item'},
        {label: 'Code Block', style: 'code-block'},
      ];

      const BlockStyleControls = (props) => {
        const {editorState} = props;
        const selection = editorState.getSelection();
        const blockType = editorState
          .getCurrentContent()
          .getBlockForKey(selection.getStartKey())
          .getType();

        return (
          <div className="RichEditor-controls">
            {BLOCK_TYPES.map((type) =>
              <StyleButton
                key={type.label}
                active={type.style === blockType}
                label={type.label}
                onToggle={props.onToggle}
                style={type.style}
              />
            )}
          </div>
        );
      };

      var INLINE_STYLES = [
        {label: 'Bold', style: 'BOLD'},
        {label: 'Italic', style: 'ITALIC'},
        {label: 'Underline', style: 'UNDERLINE'},
        {label: 'Monospace', style: 'CODE'},
        {label: 'Leaf', style: 'LEAF'},
        {label: 'Highlight', style: 'HIGHLIGHT'},
      ];

      const InlineStyleControls = (props) => {
        const currentStyle = props.editorState.getCurrentInlineStyle();

        return (
          <div className="RichEditor-controls">
            {INLINE_STYLES.map((type) =>
              <StyleButton
                key={type.label}
                active={currentStyle.has(type.style)}
                label={type.label}
                onToggle={props.onToggle}
                style={type.style}
              />
            )}
          </div>
        );
      };

      const authorIds = ['*', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
      const explicitAuthorsCount = 3;

      const applyCollaborativeData = (content) => {
        var index = 0;

        const getSelectionIdAfter = (id, authorId) => `${id}/${authorId}`;
        const getNextCollaborativeId = (authorId) => `${index++}`.padStart(10, '0') + '/' + authorId;

        var authorIndex = 0;
        var selectionAuthorIndex = 1;

        var wordIndex = 0;

        const blocks = content.getBlocksAsArray();
        const newBlocks = blocks.map((block, blockIndex) => {
          const blockId = getNextCollaborativeId(authorIds[blockIndex] || '*');
          const selections = [];

          const text = block.getText();
          if (!text) {
              const caretInEmptyBlock = UserSelection.create(
                getSelectionIdAfter(blockId, 'B'),
                getSelectionIdAfter(blockId, 'B'),
                'B'
              );

              return block.merge({
                id: blockId,
                selections: List([caretInEmptyBlock]),
              });
          }

          const characterMetadata = block.getCharacterList().toArray();

          var wordStartId = blockId;
          const characterIds = text.split('').map(
            (ch, charIndex) => {
              // Each word has a different author
              const isSpace = (ch === ' ');

              const hasAuthor = (wordIndex % 2) === 1;
              const wordAuthorId = hasAuthor ? authorIds[authorIndex] : undefined;

              const charId = getNextCollaborativeId(wordAuthorId || '*');
              wordStartId = isSpace ? charId : wordStartId;
              if (hasAuthor && (authorIndex > 0)) {
                // Here we test the author highlight (underline)
                characterMetadata[charIndex] = CharacterMetadata.applyStyle(characterMetadata[charIndex], `author--${authorIds[authorIndex]}`);
              }

              // There is a selection after every `e`
              if (ch.toLowerCase() === 'e') {
                const isLastChar = (charIndex === text.length - 1);
                const selectionAuthorId = isLastChar
                  // Last word has explicit selection to test highlight and caret at the end of the block
                  ? 'F'
                  : (selectionAuthorIndex < authorIds.length - explicitAuthorsCount)
                    ? authorIds[selectionAuthorIndex]
                    : undefined;

                if (selectionAuthorId) {
                  const isAtTheWordEnd = (text[charIndex + 1] === ' ') || isLastChar;

                  // If `e` is at the end of the word, the selection is over the entire word
                  if (isAtTheWordEnd) {
                    // If the word is 'the', the selection is backward to test backward selection display
                    // Both at editor start and in the middle of the text
                    const isThe = (text[charIndex - 2].toLowerCase() === 't') && (text[charIndex - 1].toLowerCase() === 'h');
                    if (isThe) {
                      const fullWordSelectionBackwards = UserSelection.create(
                        getSelectionIdAfter(charId, selectionAuthorId),
                        getSelectionIdAfter(wordStartId, selectionAuthorId),
                        selectionAuthorId
                      );
                      selections.push(fullWordSelectionBackwards);
                    } else {
                      // Otherwise we test forward selection highlight
                      const fullWordSelection = UserSelection.create(
                        getSelectionIdAfter(wordStartId, selectionAuthorId),
                        getSelectionIdAfter(charId, selectionAuthorId),
                        selectionAuthorId
                      );
                      selections.push(fullWordSelection);
                    }
                  } else {
                    // In all other cases we test collapsed selection (caret only)
                    const collapsedSelection = UserSelection.create(
                      getSelectionIdAfter(charId, selectionAuthorId),
                      getSelectionIdAfter(charId, selectionAuthorId),
                      selectionAuthorId
                    );
                    selections.push(collapsedSelection);
                  }

                  selectionAuthorIndex++;
                }
              }

              if (isSpace) {
                wordIndex++;
                if (hasAuthor) {
                  authorIndex = (authorIndex + 1) % authorIds.length;
                }
              }

              return charId;
            }
          );

          const newBlock = block.merge({
            // Each block has a different author
            id: blockId,
            characterIds,
            characterList: List(characterMetadata),
            selections: List(selections),
          });
          console.log(newBlock.toJS());

          return newBlock;
        });

        var addSelections = [];
        const newBlocksWithMultiBlockSelections = newBlocks.map((block, blockIndex) => {
          const updatedBlock = (addSelections.length > 0)
            ? block.merge({
              selections: block.selections.push(...addSelections)
            })
            : block;

          addSelections = [];

          if (updatedBlock.getText()) {
            return updatedBlock;
          }

          // When there is an empty block, create a multi-block selection reaching the next block to test highlight of the empty block within selection
          const nextBlock = newBlocks[blockIndex + 1];
          if (nextBlock) {
            const nextBlockCharacterIds = nextBlock.getCharacterIds();
            const endSelectionCharacterId = nextBlockCharacterIds.get(5) || nextBlockCharacterIds.last();
            const multiBlockSelection = UserSelection.create(
              getSelectionIdAfter(updatedBlock.getId(), 'G'),
              getSelectionIdAfter(endSelectionCharacterId, 'G'),
              'G'
            );
            addSelections.push(multiBlockSelection);

            return block.merge({
              selections: block.selections.push(...addSelections)
            });
          }

          return updatedBlock;
        });

        return ContentState.createFromBlockArray(newBlocksWithMultiBlockSelections);
      };

      const content = ContentState.createFromText(
`The selections are shown with the colored caret and background, the content has the author color as underline

^ Above is an empty block with caret and selection which continues to this block`);
      const collaborativeContent = applyCollaborativeData(content);

      ReactDOM.render(
        (
          <React.Fragment>
            <h2>First editor</h2>
            <RichEditorExample />
            <h2>Second editor</h2>
            <RichEditorExample />
            <h2>Collaborative display</h2>
            <p>Disabled editor, only to verify rendering of content with collaborative metadata. You should see selections for all six authors as well as content marked as produced by all of them.</p>
            <h3>Authors</h3>
            <ul className="authors">
              {authorIds.map(authorId =>
                <li key={authorId}>
                  Author {authorId}: <span className={`leaf--has-selection selection--user-${authorId} leaf--has-cursor cursor--user-${authorId}`}><span data-text="true">selection</span></span>, <span className={`leaf--has-cursor cursor--user-${authorId}`}><span data-text="true">caret</span></span>, <span className={`author--${authorId}`}><span data-text="true">content</span></span>
                </li>
              )}
            </ul>
            <RichEditorExample content={collaborativeContent} disabled />
          </React.Fragment>
        ),
        document.getElementById('target')
      );
    </script>
  </body>
</html>
